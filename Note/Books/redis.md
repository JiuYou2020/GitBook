### **《Redis设计与实现》**

 黄健宏

 94个笔记

###  **第一十四章 2.2 SDS与C字符串的区别**

- 和C字符串不同，因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O（1）。
- 与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性
- 减少修改字符串时带来的内存重分配次数
- 1.空间预分配空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间
- 通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。
- 惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。
- 通过使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据。
- 通过遵循C字符串以空字符结尾的惯例，SDS可以在有需要时重用＜string.h＞函数库，从而避免了不必要的代码重复。

###  **第一十六章 2.4 重点回顾**

- 1）常数复杂度获取字符串长度。2）杜绝缓冲区溢出。3）减少修改字符串长度时所需的内存重分配次数。4）二进制安全。5）兼容部分C字符串函数。

###  **第二十一章 3.3 重点回顾**

- ❑链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。❑每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。❑每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。❑因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。❑通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。

###  **第二十五章 4.3 解决键冲突**

- 当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）。

###  **第二十六章 4.4 rehash**

- 当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：1）服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。2）服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。
- 当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

###  **第二十七章 4.5 渐进式rehash**

- 扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。

###  **第二十九章 4.7 重点回顾**

- ❑字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。❑Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。❑当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。❑哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。❑在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。

###  **第三十章 第5章 跳跃表**

- 和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构

###  **第三十三章 5.3 重点回顾**

- ❑跳跃表是有序集合的底层实现之一。❑Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。❑每个跳跃表节点的层高都是1至32之间的随机数。❑在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。❑跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。

###  **第四十章 6.6 重点回顾**

- ❑整数集合是集合键的底层实现之一。❑整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。❑升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。❑整数集合只支持升级操作，不支持降级操作。

###  **第四十一章 第7章 压缩列表**

- 压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

###  **第四十六章 7.5 重点回顾**

- ❑压缩列表是一种为节约内存而开发的顺序型数据结构。❑压缩列表被用作列表键和哈希键的底层实现之一。❑压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。❑添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。

###  **第四十七章 第8章 对象**

- **2024/04/20 发表想法**

  嗯，不存在循环依赖问题。

  > 原文：Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。

- Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。

###  **第四十八章 8.1 对象的类型与编码**

- 通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：❑因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；❑随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；

###  **第四十九章 8.2 字符串对象**

- 可以用long double类型表示的浮点数在Redis中也是作为字符串值来保存的。

###  **第五十章 8.3 列表对象**

- 列表对象的编码可以是ziplist或者linkedlist。
- 当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：❑列表对象保存的所有字符串元素的长度都小于64字节；❑列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。

###  **第五十一章 8.4 哈希对象**

- 哈希对象的编码可以是ziplist或者hashtable。
- 另一方面，hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：❑字典的每个键都是一个字符串对象，对象中保存了键值对的键；❑字典的每个值都是一个字符串对象，对象中保存了键值对的值。
- 当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：❑哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；❑哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。

###  **第五十二章 8.5 集合对象**

- 集合对象的编码可以是intset或者hashtable。

###  **第五十六章 8.9 对象共享**

- 在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：1）将数据库键的值指针指向一个现有的值对象；2）将被共享的值对象的引用计数增一。
- 目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。
- 因此，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。

###  **第五十七章 8.10 对象的空转时长**

- 除了前面介绍过的type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：
- 如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。

###  **第六十一章 9.1 服务器中的数据库**

- Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库：
- dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16

###  **第六十二章 9.2 切换数据库**

- 在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针
- 通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是SELECT命令的实现原理
- 为了避免对数据库进行误操作，在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT命令，显式地切换到指定的数据库，然后才执行别的命令。

###  **第六十三章 9.3 数据库键空间**

- Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h/redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）

- 添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象

- **2024/04/20 发表想法**

  评估和监控Redis数据库的性能。 如果缓存命中率较高，说明大部分请求都能在Redis中找到数据，这意味着Redis在减少数据库负载和提高查询速度方面发挥了很好的作用。反之，如果缓存命中率较低，那么可能需要考虑是否需要调整数据存储策略或者查询模式，例如，是否有过多的无效键，或者是否需要调整数据的过期策略等。

  > 原文：在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。

- 在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。

- 如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作

- 如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过

- 服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作

- 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知

###  **第六十四章 9.4 设置键的生存时间或过期时间**

- 虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。
- 设置生存时间和设置过期时间的命令之间的转换
- 通过过期字典，程序可以用以下步骤检查一个给定键是否过期：1）检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。2）检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。
- 实现过期键判定的另一种方法是使用TTL命令或者PTTL命令，比如说，如果对某个键执行TTL命令，并且命令返回的值大于等于0，那么说明该键未过期。在实际中，Redis检查键是否过期的方法和is_expired函数所描述的方法一致，因为直接访问字典比执行一个命令稍微快一些。

###  **第六十五章 9.5 过期键删除策略**

- 删除策略：❑定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。❑惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。❑定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。在这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。
- 定时删除策略对内存是最友好的
- 它对CPU时间是最不友好的
- 惰性删除策略对CPU时间来说是最友好的
- 它对内存是最不友好的
- 如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。

###  **第六十六章 9.6 Redis的过期键删除策略**

- Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡

- 过期键的惰性删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查

- **2024/04/20 发表想法**

  由于随机选择的随性性，可能存在一些过期 key 始终无法删除，在 redis 6.0 及之后的版本中，为了避免这种情况，已经改为顺序遍历字典了。

  > 原文：函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键

###  **第六十七章 9.7 AOF、RDB和复制功能对过期键的处理**

- 在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。

- **2024/04/20 发表想法**

  官方文档的描述：https://redis.io/docs/latest/operate/oss_and_stack/management/replication/#how-redis-replication-deals-with-expires-on-keys

  > 原文：❑如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。❑如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。

- ❑如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。❑如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。

- 当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。

- 和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。

- **2024/04/21 发表想法**

  当前的redis文档对这点有说明 如果主服务器的某个键已过期，del指令还未来得及同步到从服务器，而从服务器有对该过期键的读取请求时，是不会返回该键的内容的，好像是根据一个时钟来实现的

  > 原文：从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。

###  **第六十八章 9.8 数据库通知**

- 服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型：❑想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE。❑想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK。❑想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE。❑想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$。❑想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为El。

###  **第六十九章 9.9 重点回顾**

- 数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。
- 数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。
- 当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。

###  **第七十章 第10章 RDB持久化**

- 我们将服务器中的非空数据库以及它们的键值对统称为数据库状态。

###  **第七十一章 10.1 RDB文件的创建与载入**

- 有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。
- SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求：
- BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件
- RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。
- 因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：❑如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。❑只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。
- Redis服务器会被阻塞，所以当SAVE命令正在执行时，客户端发送的所有命令请求都会被拒绝。
- 在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。
- 在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。
- BGREWRITEAOF和BGSAVE两个命令不能同时执行：

###  **第七十二章 10.2 自动间隔性保存**

- 因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。
- Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。

###  **第七十三章 10.3 RDB文件结构**

- 当程序读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。
- key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。
- 其中?代表的是无法用字符串形式打印出来的字节。

###  **第七十五章 10.5 重点回顾**

- ❑RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。 ❑SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。 ❑BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器。 ❑服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。 ❑RDB文件是一个经过压缩的二进制文件，由多个部分组成。 ❑对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。

###  **第七十七章 第11章 AOF持久化**

- AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的

###  **第七十八章 11.1 AOF持久化的实现**

- AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。

- 当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾

- 服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面

- **2024/04/23 发表想法**

  fsync是使用后台线程执行的

  > 原文：如果用户没有主动为appendfsync选项设置值，那么appendfsync选项的默认值为everysec

- **2024/04/23 发表想法**

  官网文档也给出了写入aof时崩溃的解决方法。

  > 原文：如果这时flushAppendOnlyFile函数被调用，假设服务器当前appendfsync选项的值为everysec，并且距离上次同步AOF文件已经超过一秒钟，那么服务器会先将aof_buf中的内容写入到AOF文件中，然后再对AOF文件进行同步。

- 如果这时flushAppendOnlyFile函数被调用，假设服务器当前appendfsync选项的值为everysec，并且距离上次同步AOF文件已经超过一秒钟，那么服务器会先将aof_buf中的内容写入到AOF文件中，然后再对AOF文件进行同步。

 来自微信读书