---
description: My honey, your poison!
---

# 吾之蜜糖



# 基础

## **equals与hashCode**

**关联和约定**

1. **哈希表的使用：** 在 Java 中，哈希表（如 `HashMap`、`HashSet` 等）是基于哈希算法实现的数据结构，它通过哈希码（hash code）来快速定位对象的存储位置。
2. **约定一：相等对象必须具有相等的哈希码：** 如果两个对象根据 `equals()` 方法判断相等（即 `obj1.equals(obj2)` 返回 `true`），那么这两个对象的哈希码必须相等（即 `obj1.hashCode() == obj2.hashCode()`）。
3. **约定二：不相等的对象尽量有不同的哈希码：** 如果两个对象根据 `equals()` 方法判断不相等，不要求它们的哈希码一定不相等，但是为了提高哈希表的性能，不相等的对象尽量有不同的哈希码，减少哈希冲突。

**为什么需要重写 `hashCode()` 方法？**

- **保证哈希表性能：** 如果重写了 `equals()` 方法，但没有重写 `hashCode()` 方法，那么两个根据 `equals()` 判断相等的对象可能会有不同的哈希码，这违反了约定一，会导致这两个对象在哈希表中无法正确被处理，甚至无法通过 `HashMap` 或 `HashSet` 正确地进行存储和检索。
- **确保对象一致性：** 重写 `hashCode()` 方法可以保证根据 `equals()` 方法判断相等的对象拥有相等的哈希码，从而在使用哈希表时能够正确地识别和处理相等的对象。

## 抽象类和接口有什么区别？

1. **成员方法实现：**
   - **抽象类：** 可以包含普通方法的实现，也可以包含抽象方法（没有具体实现，只有方法声明）。抽象类中的非抽象方法可以提供默认实现，子类可以选择性地覆盖这些方法。
   - **接口：** 只能包含抽象方法的声明，不包含方法的实现。在 Java 8 及以后的版本中，接口可以包含默认方法和静态方法的实现。
2. **多继承：**
   - **抽象类：** Java 中的类只能单继承，因此抽象类只能继承一个具体类或抽象类。但是抽象类可以实现多个接口。
   - **接口：** 接口支持多继承，一个类可以实现多个接口，从而实现多重继承的效果。
3. **构造方法：**
   - **抽象类：** 可以有构造方法，并且抽象类的构造方法在子类实例化时会被调用。
   - **接口：** 不允许有构造方法，接口中不能定义实例字段，因为接口中的方法都是抽象的，没有实例变量可以初始化。
4. **用途和设计：**
   - **抽象类：** 是对类的一种抽象，是一种模版设计。
   - **接口：** 用于定义一种能力或行为，描述了一种规范或契约，实现接口的类需要提供接口中定义的所有方法的具体实现。接口适合用于不同类之间的行为规范和统一的契约。

## Class#forName 和 ClassLoader 区别

- `Class#forName(...)` 方法，除了将类的 `.class` 文件加载到JVM 中之外，还会对类进行解释，执行类中的 `static` 块。
- ClassLoader 只干一件事情，就是将 `.class` 文件加载到 JVM 中，不会执行 `static` 中的内容，只有在 newInstance 才会去执行 `static` 块。



# 集合

## 快速失败（fail-fast）和安全失败（fail-safe）的区别

- 快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 `java.util` 包下的都是快速失败。
- 安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。在 `java.util.concurrent` 包下的全是安全失败的。

## Comparable 和 Comparator 的区别?

- Comparable 接口，在 `java.lang` 包下，用于当前对象和其它对象的比较，所以它有一个 `#compareTo(Object obj)` 方法用来排序，该方法只有一个参数。
- Comparator 接口，在 `java.util` 包下，用于传入的两个对象的比较，所以它有一个 `#compare(Object obj1, Object obj2)` 方法用来排序，该方法有两个参数。

## ArrayList 与 LinkedList 区别？

**ArrayList**

- 优点：ArrayList 是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。
- 缺点：因为地址连续，ArrayList 要移动数据，所以插入和删除操作效率比较低。

**LinkedList**

- 优点：LinkedList 基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作 add 和 remove ，LinedList 比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。
- 缺点：因为 LinkedList 要移动指针，所以查询操作性能比较低。



## ArrayList 是如何扩容

- 如果通过无参构造的话，初始数组容量为 0 ，当真正对数组进行添加时，才真正分配容量。每次按照 **1.5** 倍（位运算）的比率通过 copeOf 的方式扩容。
- 在 JKD6 中实现是，如果通过无参构造的话，初始数组容量为10，每次通过 copeOf 的方式扩容后容量为原来的 **1.5** 倍。



## HashMap 和 Hashtable 的区别

**线程安全性**

- **Hashtable：** 是线程安全的类，它的方法都是同步的（synchronized），多个线程可以安全地访问一个 `Hashtable` 实例，但这也导致在多线程环境下性能相对较低。
- **HashMap：** 是非线程安全的类，它的方法没有进行同步处理，因此多个线程同时访问 `HashMap` 可能导致数据不一致或其他问题。若需要在多线程环境下使用 `HashMap`，可以通过 `Collections.synchronizedMap()` 方法来创建同步的 `HashMap`。

**Null 键和值的处理**

- **Hashtable：** 不允许使用 null 作为键或值，否则会抛出 `NullPointerException`。
- **HashMap：** 允许使用 null 作为键和值，即 `HashMap` 中可以存储键或值为 null 的条目。

**性能**

- **HashMap：** 由于 `HashMap` 非线程安全，不进行同步处理，因此在单线程环境下性能较高。
- **Hashtable：** 由于 `Hashtable` 所有方法都进行了同步处理，因此在多线程环境下保证了线程安全，但性能相对较低。

**现状**

- **Hashtable：** 继承自 `Dictionary` 类，已经被淘汰（Deprecated）。
- **HashMap：** 实现了 `Map` 接口，是 `AbstractMap` 的子类，属于 Java Collections Framework 的一部分。

**初始容量和扩容机制**

- HashTable 中数组默认大小是 11 ，扩容方法是 `old * 2 + 1` ，HashMap 默认大小是 16 ，扩容每次为 2 的指数大小。



## HashMap 和 ConcurrentHashMap区别

1. **内部结构**：在JDK1.8之前，ConcurrentHashMap使用分段锁（Segmentation）来提供并发性。每个段本质上是一个独立的HashMap，并且拥有一个锁。在JDK1.8之后，Segmentation被移除了。ConcurrentHashMap采用了一种不同的锁机制（synchronized和CAS操作）来提高并发性。

   - 当数组中当前位置为空时，使用CAS来把新的节点写入数组中对应的位置。

   - 当数组中当前位置不为空时，通过加锁（synchronized）来添加或删除节点。如果当前位置是链表，就遍历链表找到合适的位置插入或删除节点。如果当前位置是红黑树，就按照红黑树的规则插入或删除节点。

   - 当链表长度超过阈值（默认为8）时，就把链表转换为红黑树。当红黑树节点数小于阈值（默认为6）时，就把红黑树转换为链表。

2. **线程安全**：HashMap非线程安全，不能保证在多线程环境下的共享访问，而ConcurrentHashMap是线程安全的，设计用于多线程的环境中。

3. **性能**：由于ConcurrentHashMap的线程安全特性，它在多线程环境下比HashMap有更好的性能。它通过使用复杂的锁策略和CAS操作来最小化锁的竞争。

4. **内存一致性**：ConcurrentHashMap的读操作可以不加锁，并且其写操作可以延迟更新到主存，不同步其他读写操作，而HashMap在多线程下使用时需要外部同步。

























