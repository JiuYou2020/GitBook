# Computer Network

> 计算机网络

## OSI 7层模型是什么？

1. **应用层**
   - **功能**：为计算机用户提供服务
   - **常用协议**：HTTP/HTTPS、FTP、SMTP、POP3、IMAP、Telnet、SSH、DNS、DHCP
   
2. **表示层**
   - **功能**：数据处理（编解码、加密解密、压缩解压缩）
   - **常用协议**：SSL/TLS、JPEG, GIF, PNG（图像格式）、MPEG, MP3（音视频格式）
   
3. **会话层**
   - **功能**：管理（建立、维护、重连）应用程序之间的会话
   - **常用协议**：NetBIOS、PPTP（点对点隧道协议）
   
4. **传输层**
   - **功能**：为两台主机进程之间的通信提供通用的数据传输服务
   - **常用协议**：TCP（传输控制协议）、UDP（用户数据报协议）
   
5. **网络层**
   - **功能**：路由和寻址（决定数据在网络的游走路径）
   - **常用协议**：IP（互联网协议）、ICMP（互联网控制消息协议）、IGMP（互联网组管理协议）、IPsec（用于保护 IP 层通信的协议）
   
6. **数据链路层**
   - **功能**：帧编码和误差纠正控制
   - **常用协议**：Ethernet（以太网）、PPP（点对点协议）、ARP（地址解析协议）、RARP（反向地址解析协议）、STP（生成树协议）
   
7. **物理层**
   - **功能**：透明地传送比特流传输
   - **常用协议**：以太网物理层标准（如 IEEE 802.3）、光纤分布数据接口（FDDI）、DSL（数字用户线路）、ISDN（综合业务数字网）

## TCP/IP 4层模型是什么？

1. **应用层**（定义了不同设备应用程序间信息交换的格式，消息会交给下一层传输层来传输）
2. **传输层**（负责向两台终端设备进程之间的通信提供通用的数据传输服务）
3. **网络层**（为分组交换网上的不同主机提供通信服务）
4. **网络接口层**（封装成数据帧发送到网络上）

> 为什么网络要分层？
>
> 1. **各层之间相互独立**，只需要顾好自己。
> 2. **提高整体灵活性**，高内聚，低耦合。
> 3. **大问题小化**。

## 应用层常见协议有哪些？

![应用层常见协议](./.gitbook/assets/3014862-20231012154159098-1147040260.png)

- **HTTP（Hypertext Transfer Protocol，超文本传输协议）**：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。

- **SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）**：基于 TCP 协议，是一种用于发送电子邮件的协议。

  > 注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。

- **POP3/IMAP（邮件接收协议）**：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。

- **FTP（File Transfer Protocol，文件传输协议）** : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。

- **Telnet（远程登陆协议）**：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。

- **SSH（Secure Shell Protocol，安全的网络传输协议）**：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务

- **RTP（Real-time Transport Protocol，实时传输协议）**：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。

- **DNS（Domain Name System，域名管理系统）**: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。

关于这些协议的详细介绍请看 [应用层常见协议总结（应用层）]() 这篇文章。

## 传输层常见协议有哪些？

![image-20240710131410242](./.gitbook/assets/image-20240710131410242.png)

- **TCP（Transmisson Control Protocol，传输控制协议 ）**：提供 **面向连接** 的，**可靠** 的数据传输服务。
- **UDP（User Datagram Protocol，用户数据协议）**：提供 **无连接** 的，**尽最大努力** 的数据传输服务（不保证数据传输的可靠性），简单高效。



## 网络层常见协议有哪些？

![image-20240710131445341](./.gitbook/assets/image-20240710131445341.png)

- **IP（Internet Protocol，网际协议）**：TCP/IP 协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。
- **ARP（Address Resolution Protocol，地址解析协议）**：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。
- **ICMP（Internet Control Message Protocol，互联网控制报文协议）**：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。
- **NAT（Network Address Translation，网络地址转换协议）**：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。
- **OSPF（Open Shortest Path First，开放式最短路径优先）** ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。
- **RIP(Routing Information Protocol，路由信息协议）**：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。
- **BGP（Border Gateway Protocol，边界网关协议）**：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。

## 网络接口层常见协议有哪些?

![image-20240710131542763](./.gitbook/assets/image-20240710131542763.png)

我们可以把网络接口层看作是数据链路层和物理层的合体。

1. 数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。**数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。**
2. **物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异**





## 从输入 URL 到页面展示到底发生了什么？

1. DNS 解析
2. TCP 连接
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 连接结束





## 常见HTTP状态码有哪些？

![http-status-code.png](./.gitbook/assets/3014862-20231012154200380-926427171.png)

- **200**：OK（ok）
- **301**：Moved Permanently（永久重定向）
- **302**：Found（临时重定向）
- **400**：Bad Request（HTTP请求有问题，比如参数不合法，请求方法错误等）
- **401**：Unauthorized（未认证）
- **403**：Forbidden（直接拒绝，针对非法请求，没有权限等）
- **500**：Internal Server Error（服务器问题，抛异常且未处理）
- **502**：Bad Gateway：（我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应）





## 请求头Header中常见的字段有哪些？

| 字段名         | 说明                                                         | 示例                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Accept         | 能够接受的回应内容类型                                       | Accept: text/plain                                           |
| Authorization  | 用于超文本传输协议的认证的认证信息                           | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==            |
| Content-Length | 以八位字节数组 （8 位的字节）表示的请求体的长度              | Content-Length: 348                                          |
| Content-Type   | 请求体的 多媒体类型 （用于 POST 和 PUT 请求中）              | Content-Type: application/x-www-form-urlencoded              |
| Cookie         | 之前由服务器通过 Set- Cookie 发送的一个超文本传输协议 Cookie | Cookie: $Version=1; Skin=new;                                |
| Host           | 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。 | Host: en.wikipedia.org:80                                    |
| Origin         | 发起一个针对 跨来源资源共享 的请求。                         | Origin: http://www.example-social-network.com                |
| Upgrade        | 要求服务器升级到另一个协议。                                 | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11               |
| User-Agent     | 浏览器的浏览器身份标识字符串                                 | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |





## HTTP

### HTTP和HTTPS的区别？

1. **端口**：80和443
2. **URL前缀**：http和https
3. **安全性**：http基于tcp，明文传输，不安全；https基于SSL/TSL（基于TCP），内容对称加密，安全但耗费更多资源
4. **SEO**（搜索引擎优化）：https会被优先展示。



### HTTP/1.0和HTTP/1.1的区别？

![img](./.gitbook/assets/3014862-20231012154200755-592565973.png)

1. **连接方式**：短链接（连一次用完就断）和长连接
2. **状态码**：1.1新增了很多状态码
3. **缓存策略**：1.1更多样（基于请求头）
4. **带宽**：1.1可以请求资源的一部分



### HTTP/1.1 和 HTTP/2.0的区别?



![img](./.gitbook/assets/3014862-20231012154201133-1687457681.png)

1. **IO 多路复用**（Multiplexing）：HTTP/2.0 在同一连接上可以同时传输多个请求和响应；1.1是串行
2. **二进制帧**（Binary Frames）：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗
3. **头部压缩**（Header Compression）：2.0支持Header和body压缩，1.1只支持body压缩
4. **服务器推送**（Server Push）：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟



### HTTP/2.0 和 HTTP/3.0的区别?

1. **传输协议**：HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） 协议（UDP增强版，有加密、重传等功能）来实现可靠的传输

2. **连接建立**：由于 QUIC 协议的特性，HTTP/3.0 可以避免 TCP 三次握手的延迟，允许在第一次连接时发送数据（0 个 RTT ，零往返时间）。

   



### HTTP 是不保存状态的协议, 如何保存用户状态?

HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。

那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

如果Cookie被禁用，可以直接把Session ID放在请求URL后面。



## Cookie和Session的区别?

- `Cookies` 是某些网站为了辨别用户身份而储存在用户本地终端上的数据（通常经过加密）。
- **`Cookie` 存放在客户端，一般用来保存用户信息**。
- **`Session` 的主要作用就是通过服务端记录用户的状态。**
- 关联：sessionId



## URL和URI的区别?

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

> 可以将URI理解为身份证，而URL理解为家庭住址



## Post为何会发送两次请求?

当使用 XMLHttpRequest 或 Fetch API 发起跨域请求时，浏览器会先发送一个 OPTIONS 请求，这被称为预检请求，以检查服务器是否允许该跨域请求。这种情况通常发生在使用复杂请求时，比如带有自定义头部或使用方法是 POST 的请求。

- **第一次请求**：OPTIONS 预检请求。
- **第二次请求**：实际的 POST 请求。



## DNS

### DNS的作用?

DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是域名和 IP 地址的映射问题。是应用层协议，基于UDP。

![img](./.gitbook/assets/3014862-20231012154201731-1246605701.png)

### DNS服务器有哪些？

- **根 DNS 服务器**：根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。
- **顶级 DNS 服务器**：顶级域是指域名的后缀，如com、org、net和edu等。
- **权威 DNS 服务器**：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。
- **本地 DNS 服务器**：每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。



### DNS解析过程？

从本地到根DNS服务器查询，有递归查询和迭代查询两种方式。

**递归查询（Recursive Query）**

- **定义**：递归查询是DNS解析器代表客户端向上级DNS服务器请求域名解析结果，并继续向下一层服务器请求，直到获得最终结果的过程。
- **特点**：
  - 客户端只向DNS解析器发送一次请求，剩余的查询由解析器完成。
  - DNS解析器会负责查询的所有步骤，直到找到最终IP地址。
  - 查询过程中，解析器会逐级向上级服务器发出请求。

**迭代查询（Iterative Query）**

- **定义**：迭代查询是指DNS解析器在查询过程中，每次只从上级DNS服务器获取下一步要查询的服务器地址，而不会继续向下一层查询。
- **特点**：
  - DNS解析器逐级向根服务器、TLD服务器和权威服务器发出查询请求，每次请求只获取下一步查询的服务器地址。
  - 解析器会逐层查询，直到找到最终的IP地址。



## TCP 与 UDP

### TCP和UDP的区别？

1. **是否面向连接**：UDP 在传送数据之前不需要先建立连接。而 TCP 在传送数据之前必须先建立连接，数据传送结束后要释放连接。
2. **是否是可靠传输**：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。
3. **是否有状态**：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。
4. **传输效率**：TCP 的传输效率要比 UDP 低很多。
5. **传输形式**：TCP 是面向字节流的，UDP 是面向报文的。
6. **首部开销**：TCP 首部开销比 UDP 首部开销要大。
7. **是否提供广播或多播服务**：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多

|                            | TCP            | UDP        |
| -------------------------- | -------------- | ---------- |
| **是否面向连接**           | 是             | 否         |
| **是否可靠**               | 是             | 否         |
| 是否有状态                 | 是             | 否         |
| **传输效率**               | 较慢           | 较快       |
| 传输形式                   | 字节流         | 数据报文段 |
| 首部开销                   | 20 ～ 60 bytes | 8 bytes    |
| **是否提供广播或多播服务** | 否             | 是         |



### HTTP基于TCP还是UDP？

HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 **基于 UDP 的 QUIC 协议** 。此变化解决了 HTTP/2 中存在的队头阻塞问题。由于 HTTP/2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。另外，HTTP/2.0 需要经过经典的 TCP 三次握手过程（一般是 3 个 RTT）。由于 QUIC 协议的特性，HTTP/3.0 可以避免 TCP 三次握手的延迟，允许在第一次连接时发送数据（0 个 RTT ，零往返时间）。

相关证明可以参考下面这两个链接：

- https://zh.wikipedia.org/zh/HTTP/3
- https://datatracker.ietf.org/doc/rfc9114/



### 使用TCP的协议有哪些？

HTTP、HTTPS、FTP、SMTP、POP3/IMAP、Telnet、SSH



### 使用UDP的协议有哪些？

DNS、DHCP（动态主机配置协议，动态配置 IP 地址）



### TCP的三次握手和四次挥手 

![image-20240710133458365](./.gitbook/assets/image-20240710133458365.png)

**TCP三次握手**：三次握手（Three-Way Handshake）是TCP用于建立连接的过程。其主要目的是确认双方的接收和发送能力，确保连接是可靠的。

1. **第一次握手（SYN）**：
    - 客户端向服务器发送一个SYN（同步序列编号）报文，用来请求建立连接。
    - 报文中包含一个初始序列号（Sequence Number，Seq=x），这个序列号是客户端选择的随机数。
    - 客户端进入SYN_SENT状态。

    ```plaintext
    Client: SYN (Seq=x) --> Server
    ```

2. **第二次握手（SYN-ACK）**：
    - 服务器接收到客户端的SYN报文后，向客户端发送一个SYN-ACK（同步和确认）报文，表示同意建立连接并确认客户端的SYN报文。
    - 报文中包含服务器的初始序列号（Seq=y）和对客户端序列号的确认号（Acknowledge Number，Ack=x+1）。
    - 服务器进入SYN_RECEIVED状态。

    ```plaintext
    Server: SYN-ACK (Seq=y, Ack=x+1) --> Client
    ```

3. **第三次握手（ACK）**：
    - 客户端接收到服务器的SYN-ACK报文后，向服务器发送一个确认报文（ACK）。
    - 报文中包含客户端对服务器序列号的确认号（Ack=y+1）。
    - 客户端进入ESTABLISHED状态，服务器接收到ACK报文后也进入ESTABLISHED状态，连接建立完成。

    ```plaintext
    Client: ACK (Ack=y+1) --> Server
    ```

**TCP四次挥手**

![image-20240710133530874](./.gitbook/assets/image-20240710133530874.png)

四次挥手（Four-Way Handshake）是TCP用于终止连接的过程。其主要目的是确保双方都可以自由地发送完所有的数据，然后才关闭连接。

1. **第一次挥手（FIN）**：
    
    - 客户端向服务器发送一个FIN（结束标志）报文，表示客户端不再发送数据，但仍可以接收数据。
    - 客户端进入FIN_WAIT_1状态。
    
    ```plaintext
    Client: FIN (Seq=u) --> Server
    ```
    
2. **第二次挥手（ACK）**：
    
    - 服务器接收到客户端的FIN报文后，向客户端发送一个确认报文（ACK）。
    - 报文中包含对客户端FIN报文序列号的确认号（Ack=u+1）。
    - 服务器进入CLOSE_WAIT状态，客户端接收到ACK报文后进入FIN_WAIT_2状态。
    
    ```plaintext
    Server: ACK (Ack=u+1) --> Client
    ```
    
3. **第三次挥手（FIN）**：
    - 服务器准备好关闭连接后，向客户端发送一个FIN报文，表示服务器不再发送数据，但仍可以接收数据。
    - 服务器进入LAST_ACK状态。

    ```plaintext
    Server: FIN (Seq=v) --> Client
    ```

4. **第四次挥手（ACK）**：
    
    - 客户端接收到服务器的FIN报文后，向服务器发送一个确认报文（ACK）。
    - 报文中包含对服务器FIN报文序列号的确认号（Ack=v+1）。
    - 客户端进入TIME_WAIT状态，在等待一定时间（通常是2倍的MSL，Maximum Segment Lifetime）后进入CLOSED状态，服务器接收到ACK报文后立即进入CLOSED状态，连接关闭完成。
    
    ```plaintext
    Client: ACK (Ack=v+1) --> Server
    ```



### TCP 如何保证传输的可靠性？

**基于数据块传输**：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。

**对失序数据包重新排序以及去重**：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。

**校验和** : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

**超时重传** : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为[已丢失](https://zh.wikipedia.org/wiki/丢包)并进行重传。

**流量控制** : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。

**拥塞控制** : 当网络拥塞时，减少数据的发送。





## IP

### IP协议的作用？

属于网络层协议，主要作用是**定义数据包的格式、对数据包进行路由和寻址**，以便它们可以跨网络传播并到达正确的目的地。分为IPv4和IPv6



### 什么是 IP 地址？IP 寻址如何工作？

每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 IP 地址（Internet Protocol address），作为唯一标识符。

当网络设备发送 IP 数据包时，数据包中包含了 源 IP 地址 和 目的 IP 地址 。

网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。



### IPv4 和 IPv6 有什么区别？

IPv4是目前广泛使用的 IP 地址版本，其格式是四组由点分隔的数字，例如：123.89.46.72。IPv4 使用 32 位地址作为其 Internet 地址，这意味着共有约 2^32个可用 IP 地址。

不够用就有了IPv6，由单或双冒号分隔的一组数字和字母，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334 。IPv6 使用 128 位互联网地址，这意味着越有 2^128 个可用 IP 地址。还有一些其他优势：

- **无状态地址自动配置（Stateless Address Autoconfiguration，简称 SLAAC）**：主机可以直接通过根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP（Dynamic Host Configuration Protocol）服务器，简化了网络配置和管理。
- **NAT（Network Address Translation，网络地址转换） 成为可选项**：IPv6 地址资源充足，可以给全球每个设备一个独立的地址。
- **对标头结构进行了改进**：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。
- **可选的扩展头**：允许在 IPv6 标头中添加不同的扩展头（Extension Headers），用于实现不同类型的功能和选项。
- ......





### NAT的作用？

**NAT（Network Address Translation，网络地址转换）** 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。

NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。

![img](./.gitbook/assets/3014862-20231012154202156-890757619.jpg)









### Mac地址是什么？

MAC 地址的全称是 **媒体访问控制地址（Media Access Control Address）**。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。

MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。

最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。



### ARP 协议解决了什么问题地位如何？

ARP 协议，全称 **地址解析协议（Address Resolution Protocol）**，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。
